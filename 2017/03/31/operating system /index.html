<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="知识点,操作系统," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="漫画讲解
操作系统的设计，因此可以归结为三点：
以多进程形式，允许多个任务同时运行；
以多线程形式，允许单个任务分成不同的部分运行；
提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识点">
<meta property="og:url" content="http://yoursite.com/2017/03/31/operating system /index.html">
<meta property="og:site_name" content="做最好的自己">
<meta property="og:description" content="漫画讲解
操作系统的设计，因此可以归结为三点：
以多进程形式，允许多个任务同时运行；
以多线程形式，允许单个任务分成不同的部分运行；
提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。">
<meta property="og:image" content="http://yoursite.com/uploads/images/1.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/2.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/3.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/4.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/5.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/6.png">
<meta property="og:image" content="http://yoursite.com/uploads/images/7.png">
<meta property="og:updated_time" content="2017-04-08T15:40:46.449Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="操作系统知识点">
<meta name="twitter:description" content="漫画讲解
操作系统的设计，因此可以归结为三点：
以多进程形式，允许多个任务同时运行；
以多线程形式，允许单个任务分成不同的部分运行；
提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。">
<meta name="twitter:image" content="http://yoursite.com/uploads/images/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/31/operating system /"/>





  <title> 操作系统知识点 | 做最好的自己 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">做最好的自己</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/31/operating system /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="LiRuifang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="做最好的自己">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                操作系统知识点
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-31T12:24:30+08:00">
                2017-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识点/" itemprop="url" rel="index">
                    <span itemprop="name">知识点</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/知识点/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="漫画讲解"><a href="#漫画讲解" class="headerlink" title="漫画讲解"></a><a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="external"><strong>漫画讲解</strong></a></h3><ul>
<li>操作系统的设计，因此可以归结为三点：<ol>
<li>以多进程形式，允许多个任务同时运行；</li>
<li>以多线程形式，允许单个任务分成不同的部分运行；</li>
<li>提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。</li>
</ol>
</li>
</ul>
<a id="more"></a>
<h3 id="进程的几种状态"><a href="#进程的几种状态" class="headerlink" title="进程的几种状态"></a><a href="http://www.cnblogs.com/zxf98/p/5716296.html" target="_blank" rel="external">进程的几种状态</a></h3><ul>
<li>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</li>
<li>进程状态：一个进程的生命周期可以划分为一组状态，这些状态刻画了整个进程。进程状态即体现一个进程的生命状态。</li>
<li><p>一般来说，进程有三个状态，即就绪状态，运行状态，阻塞状态。</p>
<ol>
<li><strong>运行态</strong>：进程占用CPU，并在CPU上运行；</li>
<li><strong>就绪态</strong>：进程已经具备运行条件，但是CPU还没有分配过来；</li>
<li><strong>阻塞态</strong>：进程因等待某件事发生而暂时不能运行。<br><img src="/uploads/images/1.png" alt="image"></li>
</ol>
</li>
<li><p>当然理论上上述三种状态之间转换分为六种情况；</p>
<pre><code>1.运行——&gt;就绪：

1)主要是进程占用CPU的时间过长，而系统分配给该进程占用CPU的时间是有限的；
2)在采用抢先式优先级调度算法的系统中,当有更高优先级的进程要运行时，该进程就被迫让出CPU，该进程便由执行状态转变为就绪状态。

2.就绪——&gt;运行：

运行的进程的时间片用完，调度就转到就绪队列中选择合适的进程分配CPU

3.运行——&gt;阻塞：

正在执行的进程因发生某等待事件而无法执行，则进程由执行状态变为阻塞状态，如发生了I/O请求

4.阻塞——&gt;就绪:

进程所等待的事件已经发生，就进入就绪队列

以下两种状态是不可能发生的：

5.阻塞——&gt;运行：

即使给阻塞进程分配CPU，也无法执行，操作系统在进行调度时不会从阻塞队列进行挑选，而是从就绪队列中选取

6.就绪——&gt;阻塞：

就绪态根本就没有执行，谈不上进入阻塞态。
</code></pre></li>
<li><p>在一些系统中，又增加了一些新状态，如挂起状态，可运行状态，深度睡眠状态，浅度睡眠状态，暂停状态，僵死状态。</p>
</li>
<li><p><strong>挂起状态</strong>：在执行状态的进程通过挂起即可进入就绪状态，就绪状态和阻塞状态都分为活动态和静止态。由活动态向静止态转换就是通过挂起实现的。<br><img src="/uploads/images/2.png" alt="image"></p>
<pre><code>引入挂起状态的原因有：

(1) 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态称为挂起状态。　

(2) 父进程请求。有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。

(3) 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。

(4) 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。
</code></pre></li>
<li><strong>可运行状态</strong>：运行状态和就绪状态的合并，表示进程正在运行或准备运行</li>
<li><strong>浅度睡眠状态</strong>：进程正在睡眠（被阻塞），等待资源的到来是唤醒，也可以通过其他进程信号或时钟中断唤醒，进入运行队列。</li>
<li><strong>深度睡眠状态</strong>：其和浅度睡眠基本类似，但不可被其他进程信号或时钟中断唤醒。</li>
<li><strong>暂停状态</strong>：进程暂停执行接受某种处理。</li>
<li><strong>僵死状态</strong>：进程已经结束但未释放进程控制块（PCB）。</li>
</ul>
<h3 id="进程间-Inter-Process-Communication-IPC-几种通信方式"><a href="#进程间-Inter-Process-Communication-IPC-几种通信方式" class="headerlink" title="进程间(Inter-Process Communication, IPC)几种通信方式"></a>进程间(Inter-Process Communication, IPC)几种通信方式</h3><ul>
<li><strong>管道( pipe )</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li>
<li><strong>有名管道 (named pipe)</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li>
<li><strong>信号 ( sinal )</strong> ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li>
<li><strong>消息队列( message queue )</strong> ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>
<li><strong>共享内存( shared memory )</strong> ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li>
<li><strong>内存映射</strong>：<br>内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li><strong>信号量( semophore )</strong>： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>套接字( socket )</strong> ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li>
</ul>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。</li>
<li>内存在计算机中的作用很大，电脑中所有运行的程序都需要经过内存来执行，如果执行的程序很大或很多，就会导致内存消耗殆尽。为了解决这个问题，WINDOWS运用了虚拟内存技术，即拿出一部分硬盘空间来充当内存使用，这部分空间即称为虚拟内存，虚拟内存在硬盘上的存在形式就是 PageFile.Sys这个页面文件。</li>
</ul>
<h3 id="段存储，页存储，段页存储"><a href="#段存储，页存储，段页存储" class="headerlink" title="段存储，页存储，段页存储"></a><a href="http://blog.csdn.net/wang379275614/article/details/13765599" target="_blank" rel="external">段存储，页存储，段页存储</a></h3><ul>
<li><h4 id="基本的存储方式"><a href="#基本的存储方式" class="headerlink" title="基本的存储方式"></a>基本的存储方式</h4><img src="/uploads/images/3.png" alt="image"></li>
<li><h4 id="页存储"><a href="#页存储" class="headerlink" title="页存储"></a>页存储</h4><p>将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。</p>
<p><strong>步骤</strong>：</p>
<pre><code>1. 逻辑空间等分为页；并从0开始编号；
2. 内存空间等分为块，与页面大小相同；从0开始编号；
3. 分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。
</code></pre><p><strong>地址结构</strong>：<br><img src="/uploads/images/4.png" alt="image"></p>
<pre><code>1. 分两部分：页号、位移量（页内地址）
2. 页内地址的位数可以决定页的大小（如上图每页大小为4K，页内地址的长度为12位，212=4096，即4K）。
3. 页号长度为21-12+1=10,210=1024，每个段的大小均为1024个页。
4. 逻辑地址=页号&amp;位移量（&amp;号是连接符号，是将页号作为逻辑地址的最高位）
</code></pre></li>
<li><h4 id="段存储"><a href="#段存储" class="headerlink" title="段存储"></a>段存储</h4><p><strong>步骤</strong>:</p>
<pre><code>1. 逻辑空间分为若干个段，每个段定义了一组有完整逻辑意义的信息。
2. 内存空间为每个段分配一个连续的分区
3. 段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，引入分段存储管理方式的目的主要是为了满足用户（程序员）在编程和使用上多方面的要求。
4. 要注重理解，**完整的逻辑意义信息**，就是说将程序分页时，页的大小是固定的，只根据页面大小大小死生生的将程序切割开；而分段时比较灵活，只有一段程序有了完整的意义才将这一段切割开。
</code></pre><p><strong>地址结构</strong>：</p>
<p><img src="/uploads/images/5.png" alt="image"></p>
<pre><code>1. 段内地址的位数可以决定段的大小
2. 逻辑地址=段号&amp;段内地址（&amp;号是连接符号，是将段号作为逻辑地址的最高位）
</code></pre></li>
<li><h4 id="分页和分段的区别"><a href="#分页和分段的区别" class="headerlink" title="分页和分段的区别"></a>分页和分段的区别</h4><p><img src="/uploads/images/6.png" alt="image"></p>
</li>
<li><h4 id="段页存储"><a href="#段页存储" class="headerlink" title="段页存储"></a>段页存储</h4><p><strong>步骤：</strong><br>  用户程序先分段，每个段内部再分页（内部原理同基本的分页、分段相同）</p>
<p><strong>地址结构</strong>：</p>
<p><img src="/uploads/images/7.png" alt="image"></p>
<pre><code>1.分三部分：段号、段内页号、页内地址。
2.页内地址的长度为12位，212=4096，即4K，页号长度为21-12+1=10,210=1024，段号长度为31-22+1=10,210 =1024。因此：系统最多可有1024个段，每个段最大允许有1024个页，页的大小为4K。
</code></pre></li>
<li><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在页式、段式存储管理中，为获得一条指令或数据，须两次访问内存；而段页式则须三次访问内存</p>
</li>
</ul>
<h3 id="虚拟地址、逻辑地址、线性地址、物理地址的区别"><a href="#虚拟地址、逻辑地址、线性地址、物理地址的区别" class="headerlink" title="虚拟地址、逻辑地址、线性地址、物理地址的区别"></a>虚拟地址、逻辑地址、线性地址、物理地址的区别</h3><ul>
<li><h4 id="虚拟地址"><a href="#虚拟地址" class="headerlink" title="虚拟地址"></a>虚拟地址</h4>虚拟地址是由程序产生的由段选择符和段内偏移地址组成的地址。这两部分组成的地址并没有直接访问物理内存，而是要通过分段地址的变换处理后才会对应到相应的物理内存地址。</li>
<li><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4>逻辑地址指由程序产生的段内偏移地址，指的是机器语言指令中，用来指定一个操作数或者是一条指令的地址。有时把逻辑地址当成虚拟地址，两者并没有明确的界限。</li>
<li><h4 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h4>线性地址是指虚拟地址到物理地址变换的中间层， 是处理器可寻址的内存空间（称为线性地址空间）中的地址。程序代码会产生逻辑地址，或者说段中的偏移地址，加上相应段基址就生成了一个线性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若是没有采用分页机制，那么线性地址就是物理地址。</li>
<li><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4>物理地址是指现在 CPU 外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。</li>
<li><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4>逻辑地址(段表）—-&gt; 线性地址（页表）—–&gt;物理地址。</li>
</ul>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul>
<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。<br>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),这样线程就可以轻装上阵，提高系统的并发程度。它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li>
<li>一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.</li>
<li>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</li>
</ul>
<h3 id="进程调度的一些算法策略"><a href="#进程调度的一些算法策略" class="headerlink" title="进程调度的一些算法策略"></a>进程调度的一些算法策略</h3><ul>
<li><p>调度算法是指：根据系统资源分配策略所规定的资源分配算法。</p>
</li>
<li><h4 id="先来先服务和短作业（进程）优先调度算法"><a href="#先来先服务和短作业（进程）优先调度算法" class="headerlink" title="先来先服务和短作业（进程）优先调度算法"></a>先来先服务和短作业（进程）优先调度算法</h4></li>
<li><h5 id="1-先来先服务调度算法"><a href="#1-先来先服务调度算法" class="headerlink" title="1.先来先服务调度算法"></a>1.先来先服务调度算法</h5><p>  先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度， 也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业， 而不利于I/O繁忙型的作业（进程）。 </p>
</li>
<li><h5 id="2-短作业（进程）优先调度算法"><a href="#2-短作业（进程）优先调度算法" class="headerlink" title="2.短作业（进程）优先调度算法"></a>2.短作业（进程）优先调度算法</h5><p>  短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度，也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</p>
</li>
<li><h4 id="高优先权优先调度算法"><a href="#高优先权优先调度算法" class="headerlink" title="高优先权优先调度算法"></a>高优先权优先调度算法</h4></li>
<li><h5 id="1-优先权调度算法的类型"><a href="#1-优先权调度算法的类型" class="headerlink" title="1.优先权调度算法的类型"></a>1.优先权调度算法的类型</h5><p>  为了照顾紧迫性作业，使之进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。 此算法常被用在批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度，还可以用于实时系统中。当其用于作业调度， 将后备队列中若干个优先权最高的作业装入内存。当其用于进程调度时，把处理机分配给就绪队列中优先权最高的进程，此时， 又可以进一步把该算法分成以下两种：</p>
<ol>
<li><p><strong>非抢占式优先权算法</strong>：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；</p>
</li>
<li><p><strong>抢占式优先权调度算法</strong>（高性能计算机操作系统）：系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。</p>
</li>
</ol>
</li>
<li><h5 id="2-优先权类型"><a href="#2-优先权类型" class="headerlink" title="2.优先权类型"></a>2.优先权类型</h5><p>  对于最高优先权优先调度算法，其核心在于：它是使用静态优先权还是动态优先权， 以及如何确定进程的优先权。 </p>
</li>
<li><h5 id="3-高响应比优先调度算法："><a href="#3-高响应比优先调度算法：" class="headerlink" title="3.高响应比优先调度算法："></a>3.高响应比优先调度算法：</h5><p>  为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的优先等级随着等待时间的增加而以速率a提高。 该优先权变化规律可描述为：</p>
<pre><code>(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。
</code></pre></li>
<li><h4 id="基于时间片的轮转调度算法"><a href="#基于时间片的轮转调度算法" class="headerlink" title="基于时间片的轮转调度算法"></a>基于时间片的轮转调度算法</h4><ol>
<li><strong>时间片轮转法</strong>。时间片轮转法一般用于进程调度，每次调度，把CPU分配队首进程，并令其执行一个时间片。 当执行的时间片用完时，由一个记时器发出一个时钟中断请求，该进程被停止，并被送往就绪队列末尾；依次循环。   </li>
<li><strong>多级反馈队列调度算法</strong>。 多级反馈队列调度算法，不必事先知道各种进程所需要执行的时间，它是目前被公认的一种较好的进程调度算法。 其实施过程如下：<pre><code>1.设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中， 为每个进程所规定的执行时间片就越小。
2.当一个新进程进入内存后，首先放入第一队列的末尾，按FCFS原则排队等候调度。
  如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，在同样等待调度……
  如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。
3.仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1到第（i-1）队列空时，才会调度第i队列中的进程运行，并执行相应的时间片轮转。
4.如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列，则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。
</code></pre></li>
</ol>
</li>
</ul>
<h3 id="信号量和互斥量"><a href="#信号量和互斥量" class="headerlink" title="信号量和互斥量"></a>信号量和互斥量</h3><ul>
<li>互斥量用于线程的互斥，为协调共同对一个共享资源的单独访问而设计的。信号量用于线程的同步，为控制一个具有有限数量用户资源而设计。</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，另一个线程得到。</li>
<li>每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li>
<li>一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫”互斥锁”（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。</li>
<li>还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><h4 id="概念及原因"><a href="#概念及原因" class="headerlink" title="概念及原因"></a>概念及原因</h4>死锁：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再 向前推进。<br>产生死锁的原因：（1）竞争系统资源 （2）进程的推进顺序不当</li>
<li><h4 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h4>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
<li><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4>首先为每个进程和每个资源指定一个唯一的号码；<br>然后建立资源分配表和进程等待表</li>
<li><h4 id="死锁的恢复"><a href="#死锁的恢复" class="headerlink" title="死锁的恢复"></a>死锁的恢复</h4><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：</p>
<ol>
<li><p><strong>剥夺资源</strong> ：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；</p>
</li>
<li><p><strong>撤消进程</strong> ：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p>
</li>
</ol>
</li>
<li><h4 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h4><ol>
<li><strong>资源一次性分配</strong>：（破坏请求和保持条件）</li>
<li><strong>可剥夺资源</strong>：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）</li>
<li><strong>资源有序分配法</strong>：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ol>
</li>
<li><h4 id="死锁的避免"><a href="#死锁的避免" class="headerlink" title="死锁的避免"></a>死锁的避免</h4><p>预防死锁的几种策略，会严重地损害系统性能。因此在避免死锁时，要施加较弱的限制，从而获得较满意的系统性能。<br>由于在避免死锁的策略中，允许进程动态地申请资源。因而，系统在进行资源分配之前<strong>预先计算资源分配的安全性</strong>。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，进程等待。其中最具有代表性的避免死锁算法是<strong>银行家算法</strong>。</p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/知识点/" rel="tag"># 知识点</a>
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/29/howtonew/" rel="next" title="如何新建和撰写博客">
                <i class="fa fa-chevron-left"></i> 如何新建和撰写博客
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/01/Cache缓存之强制缓存和协商缓存/" rel="prev" title="Cache缓存之强制缓存和协商缓存">
                Cache缓存之强制缓存和协商缓存 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/images/avatar.jpg"
               alt="LiRuifang" />
          <p class="site-author-name" itemprop="name">LiRuifang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/makeefforts" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2656650574?refer_flag=1001030101_&is_all=1" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.jianshu.com/u/6b51f627d1d8" title="个人简书" target="_blank">个人简书</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/blog/archives.html" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#漫画讲解"><span class="nav-number">1.</span> <span class="nav-text">漫画讲解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的几种状态"><span class="nav-number">2.</span> <span class="nav-text">进程的几种状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间-Inter-Process-Communication-IPC-几种通信方式"><span class="nav-number">3.</span> <span class="nav-text">进程间(Inter-Process Communication, IPC)几种通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存"><span class="nav-number">4.</span> <span class="nav-text">虚拟内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段存储，页存储，段页存储"><span class="nav-number">5.</span> <span class="nav-text">段存储，页存储，段页存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的存储方式"><span class="nav-number">5.1.</span> <span class="nav-text">基本的存储方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页存储"><span class="nav-number">5.2.</span> <span class="nav-text">页存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段存储"><span class="nav-number">5.3.</span> <span class="nav-text">段存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页和分段的区别"><span class="nav-number">5.4.</span> <span class="nav-text">分页和分段的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#段页存储"><span class="nav-number">5.5.</span> <span class="nav-text">段页存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">5.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟地址、逻辑地址、线性地址、物理地址的区别"><span class="nav-number">6.</span> <span class="nav-text">虚拟地址、逻辑地址、线性地址、物理地址的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟地址"><span class="nav-number">6.1.</span> <span class="nav-text">虚拟地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑地址"><span class="nav-number">6.2.</span> <span class="nav-text">逻辑地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性地址"><span class="nav-number">6.3.</span> <span class="nav-text">线性地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理地址"><span class="nav-number">6.4.</span> <span class="nav-text">物理地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结-1"><span class="nav-number">6.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程与线程的区别"><span class="nav-number">7.</span> <span class="nav-text">进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度的一些算法策略"><span class="nav-number">8.</span> <span class="nav-text">进程调度的一些算法策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先来先服务和短作业（进程）优先调度算法"><span class="nav-number">8.1.</span> <span class="nav-text">先来先服务和短作业（进程）优先调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-先来先服务调度算法"><span class="nav-number">8.1.1.</span> <span class="nav-text">1.先来先服务调度算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-短作业（进程）优先调度算法"><span class="nav-number">8.1.2.</span> <span class="nav-text">2.短作业（进程）优先调度算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#高优先权优先调度算法"><span class="nav-number">8.2.</span> <span class="nav-text">高优先权优先调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-优先权调度算法的类型"><span class="nav-number">8.2.1.</span> <span class="nav-text">1.优先权调度算法的类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-优先权类型"><span class="nav-number">8.2.2.</span> <span class="nav-text">2.优先权类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-高响应比优先调度算法："><span class="nav-number">8.2.3.</span> <span class="nav-text">3.高响应比优先调度算法：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于时间片的轮转调度算法"><span class="nav-number">8.3.</span> <span class="nav-text">基于时间片的轮转调度算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量和互斥量"><span class="nav-number">9.</span> <span class="nav-text">信号量和互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">10.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概念及原因"><span class="nav-number">10.1.</span> <span class="nav-text">概念及原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的必要条件"><span class="nav-number">10.2.</span> <span class="nav-text">死锁的必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的检测"><span class="nav-number">10.3.</span> <span class="nav-text">死锁的检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的恢复"><span class="nav-number">10.4.</span> <span class="nav-text">死锁的恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的预防"><span class="nav-number">10.5.</span> <span class="nav-text">死锁的预防</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的避免"><span class="nav-number">10.6.</span> <span class="nav-text">死锁的避免</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LiRuifang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
